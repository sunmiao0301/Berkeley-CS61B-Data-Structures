## Reading 12.3

## 插入String —— 但不止是英文单词

![img](https://joshhug.gitbooks.io/hug61b/content/chap12/ascii)

有一种称为**ASCII**的字符格式，每个字符都有一个整数。在这里，我们看到最大值（即我们需要使用的基数/乘数）是 126。让我们这样做。相同的东西`DataIndexedEnglishWordSet`，只不过此时的base是 `126`。

```java
public static int asciiToInt(String s) {
    int intRep = 0;
    for (int i = 0; i < s.length(); i += 1) {           
        intRep = intRep * 126;
        intRep = intRep + s.charAt(i);
    }
    return intRep;
}
```

增加对中文的支持怎么样？最大可能的表示是 40959，所以我们需要使用它作为基础。这是一个例子：

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%2012.49.36%20PM.png)

所以...要存储一个 3 个字符的中文单词，我们需要一个大小大于**39 万亿**（带有 T）的数组！这已经失控了......所以让我们探索一下我们能做些什么。

## 处理整数溢出和哈希码

### 溢出问题

Java 中整数的最大可能值为 2,147,483,647。最小值是 -2,147,483,648。

**如果你尝试取最大值并加 1，你会得到最小值！**

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%2012.53.44%20PM.png)

所以，即使只有 ASCII 字符（以 126 为基数），我们仍旧会遇到问题。

`melt banana`由于int值的反向溢出，

`subterresetrial anticosmetic`实际上具有相同的表示（转一圈又回来了）。`asciiToInt`因此，如果我们添加`melt banana`然后尝试询问`contains(subterrestrial anticosmetic)`，我们会得到`true`。

### 不可避免的真相

**从最小到最大可能的整数，Java 中共有 4,294,967,296 个整数。然而，在 Java 中可以创建的对象总数不止这么多，因此冲突是不可避免的。抵抗是徒劳的。我们必须弄清楚如何正面处理碰撞，而不是试图解决它。**

（如果您不相信在 Java 中可以创建超过 40 亿个对象，只需考虑：“一”、“二”、...、“五万亿”——每一个都是唯一的字符串。 )

**我们必须处理碰撞。**

### 一个微妙的点

请注意，我们的问题本质上并不是*存在*溢出的事实。我们想要的只是一种将 a 转换`String`为数字的方法。即使*存在*溢出，我们也设法将`String`转换为数字 a 。固有的问题是由于*溢出导致冲突*，我们不知道如何处理。

溢出在其他情况*下*通常很糟糕，例如，如果您不知道溢出发生，它会产生一些意想不到的结果。但是在这里，overflow 的存在并没有破坏我们想要将 a 转换为`int`的事实。所以，我们的问题就变成了如何处理碰撞。

### 哈希码

在计算机科学中，获取一个对象并将其转换为某个整数称为“计算对象的**哈希码**”。例如，“melt banana”的哈希码是 839099497。

我们研究了如何计算字符串的哈希码。对于其他对象，我们会做以下两件事之一：

- Java 中的每个`Object`都有一个默认`.hashcode()`方法，我们可以使用它。Java 通过计算`Object`在内存中的位置来计算这一点（计算机中内存的每个部分都有一个地址！），并使用该内存的地址来做类似于我们之前对`String`s 所做的事情。此方法为每个 Java 对象提供*唯一的哈希码。*

  p.s. 考虑碰撞的情况下，多个完全相同的对象对应完全一致的哈希码，但是哈希码可能对应多种对象。

- 有时，我们编写自己的`hashcode`方法。例如，给定一个`Dog`，我们可以使用它的`name`，`age`和`breed`的组合来生成一个`hashcode`。

## 哈希码的属性

哈希码具有三个必要的属性，这意味着哈希码必须具有这些属性才能**有效**：

1. 它必须是一个整数
2. 如果我们`.hashCode()`在一个对象上运行两次，它应该返回**相同**的数字
3. 两个`.equal()`的对象必须具有相同的哈希码。

然而，并非所有的哈希码都是一样的。如果您希望您的哈希码被认为是一个**好的**哈希码，它应该：

1. 均匀分配物品

**请注意，此时，我们知道如何将任意对象添加到我们的数据结构中，而不仅仅是字符串。而完成这一转变的解决方案就是：用哈希码取代之前对`String`进行的的128进制运算**

### 未决问题

- 空间：我们还没有弄清楚如何使用更少的空间。
- 处理碰撞：我们已经确定我们需要处理碰撞，但我们还没有真正处理它们。

其他的都解决了！