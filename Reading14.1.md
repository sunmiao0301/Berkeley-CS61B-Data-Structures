## Reading 14.1 Data Structures Summary

## 搜索问题

我们面临的问题：给定一个数据流，检索感兴趣的信息。

这有哪些例子？

- 网站用户发布到个人页面。仅向朋友提供内容。
- 给定数千个气象站的日志，显示指定日期和时间的气象图。
- 狗主人需要最好的宠物店，选择以价格、质量或氛围来定义他们最好的宠物店。

到目前为止，**我们讨论的所有数据结构都是为了解决搜索问题。**我们学习的每一种数据结构都用于在特定场景中使搜索高效的方案中存储信息。

### 搜索数据结构

| 名称                      | 商店运营                        | 初级检索操作              | 检索方式                  |
| ------------------------- | ------------------------------- | ------------------------- | ------------------------- |
| List                      | `add(key)`,`insert(key, index)` | `get(index)`              | index                     |
| Map                       | `put(key, value)`               | `get(key)`                | key identity              |
| Set                       | `add(key)`                      | `containsKey(key)`        | key identity              |
| PQ                        | `add(key)`                      | `getSmallest()`           | key order（aka key size） |
| 不相交集<br>Disjoint Sets | `connect(int1, int2)`           | `isConnected(int1, int2)` | two integer values        |

请记住，这些是**抽象**数据类型。这意味着我们定义的是行为，而不是实现。我们在前面的章节中定义了许多可能的实现。让我们考虑一下这些实现和 ADT 是如何交互的：

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-13%20at%2011.37.10%20PM.png)

这张图告诉我们什么？您会注意到的第一件事是，我们在前面章节中设计的许多实现可以用于实现许多不同的 ADT。您还会注意到红色的实现（表示性能不佳），告诉我们并非所有实现都对我们试图实现的行为是最佳的。

**练习 14.1.1。**考虑如何修改这些实现中的每一个以适应试图定义的行为。例如，我们如何使用哈希表来充当优先级队列？

## 抽象

抽象经常发生在层中。抽象数据类型通常可以包含两个抽象概念，归结为一个实现。让我们考虑一些例子：

- 如果我们还记得 Priority Queue ADT，我们试图找到一种对 PQ 操作有效的实现。我们决定使用堆有序树来实现我们的优先级队列，但正如我们所见，我们有几种方法（1A、1B、1C、2、3）来表示堆树。
- 一个类似的想法是外部链接哈希表。此数据结构是使用存储桶数组实现的，但这些存储桶可以使用 ArrayList、Resizing Array、Linked List 或 BST 来完成。

这两个例子告诉我们，我们经常可以通过使用另一个 ADT 来想到一个 ADT。并且抽象数据类型具有抽象层，每个抽象层都定义了比之前的想法更具体的行为。