## Reading 11.5

# 红黑树

我们在上一节中说过，我们非常喜欢 2-3 棵树，因为它们总是保持平衡，但我们也不喜欢它们，因为它们很难实现。但为什么不两者兼而有之？为什么不创建一个使用 BST 实现但结构与 2-3 树相同并因此保持平衡的树？（请注意，在本章中，我们将专门研究 2-3 树，而不是 2-3-4 树）

**进入红黑树**

我们将通过查看 2-3 树并询问自己可以进行哪些修改来将其转换为 BST 来创建这棵树。

对于只有 2 个孩子节点的 2-3 树，我们已经有了一个 BST，所以我们不需要做任何修改！

但是，当我们得到一个 3 节点时会发生什么？

我们可以做的一件事是创建一个“胶水”节点，它不包含任何信息，仅用于显示它的 2 个子节点实际上是一个节点的一部分。

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2010.51.15%20PM.png)

然而，这是一个非常不优雅的解决方案，因为我们占用了更多空间并且代码会很丑陋。因此，我们将不使用粘合节点，而是使用粘合链接！

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2010.56.51%20PM.png)

我们任意选择使左侧元素成为右侧元素的子元素。这导致**左倾**树。我们通过将链接设为红色来表明链接是胶水链接。普通链接是黑色的。因此，我们将这些结构称为**左倾红黑树 (LLRB)**。我们将在 61B 中使用左倾树。

##### 左倾红黑树与 2-3 棵树有 1-1 对应关系。每一个 2-3 树都有一个唯一的 LLRB 红黑树与之关联。至于 2-3-4 树，它们与标准的红黑树保持对应关系。

## LLRB 的属性

以下是 LLRB 的属性：

- 1-1对应2-3棵树。
- 没有节点有 2 个红色链接。
- 没有红色的右链接。
- 从根到叶子的每条路径都有相同数量的黑色链接（因为 2-3 棵树到每个叶子的链接数量相同）。
- 高度不超过相应 2-3 树的高度的 2 倍。

## 插入 LLRB

我们总是可以通过插入 2-3 树并使用上面的方案转换它来插入 LLRB 树。但是，这将与我们创建 LLRB 的初衷背道而驰，即避免 2-3 树的复杂代码！相反，我们像使用普通 BST 一样插入 LLRB。但是，这可能会破坏其 1-1 映射到 2-3 树，因此我们将使用旋转将树按摩回适当的结构。

我们将在下面介绍插入 LLRB 时需要解决的不同任务。

1. **任务 1：插入颜色**：因为在 2-3 树中，我们总是通过添加到叶节点来插入，所以我们添加的链接的颜色应该始终为红色。

2. **任务 2：在右侧插入**：回想一下，我们使用的是*左倾*红黑树，这意味着我们永远不会有右红色链接。如果我们在右边插入，我们将需要使用旋转来保持 LLRB 不变。![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.14.41%20PM.png)
   但是，如果我们要在右边插入一个红色链接，而左边的孩子*也是*一个红色链接，那么我们将暂时允许它用于在任务 3 中变得更清楚的目的。

   ![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.33.14%20PM.png)

3. **任务 3：左侧双插入：**如果左侧有 2 个红色链接，那么我们有一个 4 节点，这是非法的。首先，我们将旋转创建与上面任务 2 中相同的树。![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.36.00%20PM.png)然后，在这两种情况下，我们都会翻转所有接触 S 的边的颜色。这相当于将 2-3 树中的中间节点向上推。

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.37.57%20PM.png)

您可能需要经过一系列旋转才能完成转换。过程是：当 LLRB 树不满足与 2-3 树的 1-1 对应关系或破坏 LLRB 不变量时，根据树的情况执行任务 1、2 或 3，直到得到合法的 LLRB。

以下是所有操作的摘要：

- 插入时：使用红色链接。
- 如果存在右倾“3 节点”，我们就有左倾违规
  - 向左旋转适当的节点进行修复。
- 如果有两个连续的左链接，我们有一个不正确的 4 Node Violation！
  - 向右旋转适当的节点进行修复。
- 如果有任何节点有两个红色的孩子，我们有一个临时的 4 节点。
  - 颜色翻转节点以模拟拆分操作。

## 运行

因为左倾红黑树与 2-3 树具有 1-1 对应关系，并且始终保持在其 2-3 树高度的 2 倍以内，因此操作的运行时间将花费\日志 N日志N *_*时间。

这是插入 LLRB 的抽象代码：

```java
private Node put(Node h, Key key, Value val) {
    if (h == null) { return new Node(key, val, RED); }

    int cmp = key.compareTo(h.key);
    if (cmp < 0)      { h.left  = put(h.left,  key, val); }
    else if (cmp > 0) { h.right = put(h.right, key, val); }
    else              { h.val   = val;                    }

    if (isRed(h.right) && !isRed(h.left))      { h = rotateLeft(h);  }
    if (isRed(h.left)  &&  isRed(h.left.left)) { h = rotateRight(h); }
    if (isRed(h.left)  &&  isRed(h.right))     { flipColors(h);      } 

    return h;
}
```

看多么短暂和甜蜜！

## 概括

- 二叉搜索树很简单，但它们会受到不平衡的影响，从而导致糟糕的运行时间。
- 2-3棵树（B树）是平衡的，但实施起来很痛苦并且相对较慢。
- LLRB 的插入很容易实现（但删除很困难）。
  - 通过使用 2-3 棵树维护数学双射来工作。
- Java 的[TreeMap](https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/util/TreeMap.java)是一棵红黑树（但不是左倾）。
- LLRB 与 2-3 树保持对应关系，标准红黑树与 2-3-4 树保持对应关系。
- 允许在任一侧使用胶水链接（参见[红黑树](http://en.wikipedia.org/wiki/Red–black_tree)）。
- 更复杂的实现，但明显更快。