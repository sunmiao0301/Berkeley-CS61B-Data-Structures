## Reading 12.4

## 处理碰撞

It's time to address the elephant in the room（是时候解决问题了——学cs61b还能学英语），最大的想法是稍微改变我们的数组，使其不仅仅包含元素Item，还能包含节点...

数组中的所有内容最初都是空的。

如果我们得到一个新元素，它的哈希码是 $h$：

- 如果此时**数组索引 $h$ 处**没有任何内容，我们将在索引处 $h$ 创建一个新的`LinkedList`，将其放置在那里，然后将新项目添加到新创建的`LinkedList`.

- 如果索引 $h$ 处已经有东西，那么意味着已经有  `LinkedList`。我们只需将我们的新项目添加到该`LinkedList`. 

  **注意：我们的数据结构不允许有任何重复的项/键。因此，我们必须首先检查我们试图插入的 Item 是否已经在这个 LinkedList 中。如果是，我们什么也不需要做！这也意味着我们将深入检查到这个索引处的链表的末端位置，因为无论如何我们都需要检查所有元素。**

### 具体工作流程

- `add`item
  - 获取项目的哈希码（即索引）。
  - 如果 index 没有项目，则创建新列表并将项目放在那里。
  - 如果 index 已经有一个 List，请检查 List 以查看 item 是否已经在其中。如果*没有*，将项目添加到列表中。
- `contains`item
  - 获取项目的哈希码（即索引）。
  - 如果 index 为空，则返回`false`。
  - 否则，检查 List 中该索引处的所有项目，如果项目存在，则返回`true`。

### 时间复杂度

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%201.19.34%20PM.png)

**为什么`contains`是Θ ( *Q* )?**
因为我们需要在哈希码（即索引）处查看 LinkedList 中的所有项目。

**为什么`add`是Θ ( *Q* )?**
难道我们不能只添加到 LinkedList 的开头吗（这只需要 θ ( 1 ) 时间）不！因为我们必须检查以确保该项目尚未在链接列表中。

你得到一些，你失去一些。

- **空间：仍未解决。**
- 处理碰撞：完成。
- 时间复杂度？为了处理碰撞，这变坏了一些。在最坏的情况下，我们所有的项目`hashcode`都可能是相同的，所以它们都进入同一个索引。如果我们有N项目，有可能他们**都**去同一个索引，创建一个长度 N 的链表，此时有最坏的时间复杂度Θ ( *N* ).

### 解决空间问题

为什么要保留一个大小为 40 亿的 ArrayList？回想一下，我们这样做是为了避免碰撞，并且希望能够将每个整数 / 单词 / 添加`String`到我们的数据结构中。*但是现在我们无论如何*都允许碰撞，我们可以稍微放松一点要求。

一个想法：模数。让我们创建一个大小为 100 的 ArrayList。我们不要更改`hashcode`函数的行为方式（让它返回一个疯狂的大整数）但是在我们得到之后`hashcode`，我们将取其模 100 来获得 0 … 99，也就是我们想要的范围。如果发生碰撞？没关系，我们知道怎么处理！

请注意，我们在数组中的 LinkedLists 现在会更长，因为我们将分散在 40 亿个索引中的所有项目压缩成 100 个索引。

### 我们做到哪儿了？

- 空间：已解决。
- 处理碰撞：完成！
- 运行时复杂度？我们早些时候已经分析了，对于`add`和`contains`，是Θ ( *Q* )，然后在本节解决空间问题中，我们意识到我们失去了更多，因为我们的 LinkedLists 可能会更大（所以`Q`会更大。）