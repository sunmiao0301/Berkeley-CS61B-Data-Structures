## 8.3 渐近学 II

### 循环示例 1

现在我们已经看到了一些运行时分析，让我们来看看一些更难的例子。我们的目标是对运行时分析中涉及的模式和方法进行一些练习。这可能是一个棘手的想法，因此练习越多越好。

上次，我们看到了函数 dup1，它第一次检查列表中的任何条目是否重复：

```java
int N = A.length;
for (int i = 0; i < N; i += 1)
   for (int j = i + 1; j < N; j += 1)
      if (A[i] == A[j])
         return true;
return false;
```

我们有两种方法来进行运行时分析：第一种，通过计算操作数；第二种，几何论证。

第一种方法：由于主要的重复操作是比较器，我们将计算必须发生的 == 操作的数量。第一次通过外循环，内循环将运行 N-1 次。第二次，它将运行 N-2 次。然后 N-3... 在最坏的情况下，我们必须遍历每个条目（外循环运行 N 次）。

最后，我们看到比较的次数是： C = 1 + 2 + 3 + ... + (N - 3) + (N - 2) + (N - 1) = N(N-1)/2

N(N-1)/2属于N^2. 因为 == 是一个常数时间操作，所以最坏情况下的总运行时间是 θ( *N*^2).

第二种方法：我们也可以从几何的角度来解决这个问题。当我们在 i,j 组合的网格中使用 == 操作时，让我们画出：

![dup_1_geometry](https://joshhug.gitbooks.io/hug61b/content/assets/dup1_square.png)

我们看到 == 操作的数量与边长为的直角三角形的面积相同，由于面积在N^2，我们再次看到整体运行时间是θ ( *N^*2).

### 循环示例  2

接下来让我们看一个更复杂的例子。考虑以下函数，具有类似的嵌套 for 循环：

```java
public static void printParty(int N) {
   for (int i = 1; i <= N; i = i * 2) {
      for (int j = 0; j < i; j += 1) {
         System.out.println("hello");   
         int ZUG = 1 + 1;
      }
   }
}
```

第一个循环每次将`i`乘以2 前进。

内部循环的`j`从 0 运行到 的当前值`i`。

循环内的两个操作都是常数时间，所以让我们计算 “对于给定的 N 值，这会打印多少次“你好”？”

```apl
对于N = 8，i运行3 + 1次
对于N = 16，运行4 + 1次
所以外层循环是logN（底数是2），
内层循环就是2^n了。
所以就是2^N * logN
```

在之前，我们通过网格（几何法）查看了 dup1 的运行时，在这里我们使用类似的方法。我们将为嵌套的 for 循环布置网格，然后跟踪下面给定 N 所需的打印语句总数。

如果 N 为 1，那么`i`只能达到 1，并且`j`只有 0，因为 0 < 1。所以只有一个 print 语句：

![回路图 1](https://joshhug.gitbooks.io/hug61b/content/assets/loops2_1.png)

如果 N 为 2，则下一次循环`i`将是1*2 = 2，并且`j`可以达到1。打印语句的总数将为第一次循环的 1 加上第二次循环的2，也就是等于 3 。

![回路图 2](https://joshhug.gitbooks.io/hug61b/content/assets/loops2_2.png)

当 N 为 3 时会发生什么？`i`是否多一次循环？

...

那么，在第二个循环之后，i = 2 * 2 = 4，大于 N，所以外循环不会继续，并在 `i = 2` 之后结束，就像 N = 2 一样。N = 3 将具有与 N = 2 相同数量的打印语句。

下一个变化是在 N=4 时，当 i = 4 时打印 4 次，当 i = 2 时打印 3 次，当 i = 1 时打印 1 次（记住`i`永远不会等于 3）。所以一共有7个。

![回路图 3](https://joshhug.gitbooks.io/hug61b/content/assets/loops2_3.png)

我们可以继续填写图表以获得更全面的信息。这里最多 N = 18：

![回路图 4](https://joshhug.gitbooks.io/hug61b/content/assets/loops2_4.png)

我们看到，如果我们将循环每个阶段的所有计数相加，打印语句的数量为：C(N) = 1 + 2 + 4 + ... + N（如果 N 是2的次方）。

但这对运行时意味着什么？

同样，我们可以从几个方面考虑这一点。由于我们已经在图形滚动上，让我们从那里开始。如果我们绘制 0.5 N（下虚线）和 4N（上虚线）和 C(N) 本身（红色楼梯线）的轨迹，我们会看到 C(N) 完全位于这两条虚线之间。

![图形](https://joshhug.gitbooks.io/hug61b/content/assets/loops2_graph.png)

**因此，运行时间（根据定义）一定是线性的！**

让我们用另一种方式来看待这个问题：

我们可以利用数学的力量从上面解出我们的方程，并发现：C(N) = 1 + 2 + 4 + ... + N = 2N - 1

*C* ( *N* ) = 1 + 2 + 4 + 。. . + *N* = 2 * *N* - 1（同样，如果 N 是 2 的幂）。

通过去除较小的项和乘法常数，我们知道 2N - 1 属于线性族。

我们还可以通过绘制 2N 在图表上看到这一点：

![图形](https://joshhug.gitbooks.io/hug61b/content/assets/loops2_graph2.png)

### 没有神奇的捷径  :(

如果有一些神奇的方法可以查看算法并*知道*它的运行时间，那就太好了。如果所有嵌套的 for 循环都是N^2. 他们不是。我们知道这一点是因为我们刚刚做了两个嵌套的 for 循环示例，每个示例都有不同的运行时。

最后，做运行时分析没有捷径可走。这需要仔细考虑。但是有一些有用的技术和事情需要知道。

**技巧：**

- *找到确切的总和*
- *写出例子*
- *画图*

我们在上面的示例中使用了其中的每一个。

**总结要知道的事情**

**这里有两个重要的总结，你会经常看到，应该记住：**

**1 + 2 + 3 + . . + *Q* = *Q* ( *Q* + 1 ) / 2 = Θ ( *Q*^2 ) （第一自然数之和的时间复杂度是平方）**

**1 + 2 + 4 + 8 + . . + *Q* = 2 * *Q* - 1 = Θ ( *Q* ) （2的一次幂之和的时间复杂度是线性）**

**您在上面分析了这两种情况，它们会在运行时分析中一次又一次地出现，所以请牢记。**

## 递归 的事件复杂度 —— 注意区分和上一个例子的差别

现在我们已经完成了几个嵌套的 for 循环，让我们看一个递归示例。考虑函数`f3`：

```java
public static int f3(int n) {
   if (n <= 1) 
      return 1;
   return f3(n-1) + f3(n-1);
}
```

这个函数有什么作用？

让我们想一个例子。如果我们调用`f3(4)`，最后我们`f3(2-1)`相加了 8 次，等于 8。我们可以将其可视化为一棵树，其中每个级别是函数的参数：

![树递归](https://joshhug.gitbooks.io/hug61b/content/assets/asymptotics2_tree.png)

你可以再做几个例子，然后会发现这个函数的返回值是 2 ^（N-1），这对于了解函数正在做什么很有用。

***直观的方法***

现在，让我们考虑一下运行时。我们可以注意到，我们每次将 N 加 1 时，我们必须完成的工作量增加一倍：

![img](https://joshhug.gitbooks.io/hug61b/content/assets/asymptotics2_tree2.png)

这个直观的论点表明运行时是2^N

这是一个很好的论点，但是让我们用更多的方式来处理这个例子。

***代数法***

解决此问题的第二种方法是计算`f3`所涉及的调用次数。例如：

*C* ( 1 ) = 1 

*C* ( 2 ) = 1 + 2

*C* ( 3 ) = 1 + 2 + 4

*C* ( *N* ) = 1 + 2 + 4 + . . + ？

我们如何概括最后一种情况？一个有用的方法是再做几个例子。

*C* ( 4 ) = 1 + 2 + 4 + 8

C ( 5 ) = 1 + 2 + 4 + 8 + 16

每个式子中的最后一项等于2 ^（N - 1）， 例如： 16 = 2 ^ {5-1}，8 = 2 ^ {4-1}

那么我们的一般形式是： C(N) = 1 + 2 + 4 + ... + 2^{N-1}

**这应该开始看起来有点熟悉。之前，我们已经总结出了规律：**

**1 + 2 + 4 + 8 + ... + Q = 2 * Q - 1**

**所以，C(N) = 2 * Q - 1 = 2 ^ N - 1**

**每次调用期间的工作是恒定的（不包括递归工作），所以这是θ (2^N).**

***重复关系***

这种方法不是必读的，不在课程范围内，但出于兴趣，值得一提。

We can use a "recurrence relation" to count the number of calls, instead of an algebraic approach. This looks like:

C(1) = 1*C*(1)=1 C(N) = 2C(N-1) + 1*C*(*N*)=2*C*(*N*−1)+1

Expanding this out with a method we will not go over but you can read about in the slides or online, we reach a similar sum to the one above, and can again reduce it to 2^N - 12*N*−1, reaching the same result of \theta(2^N)*θ*(2*N*).

## 二分搜索

二进制搜索是在列表中搜索特定项目的好方法。**它要求列表按排序顺序，并使用该事实快速查找元素。**

要进行二分搜索，我们从列表的中间开始，检查这是否是我们想要的元素。如果不是，我们问：这个元素比我们的元素大还是小？

如果它更大，那么我们知道我们只需要查看具有较小元素的列表的一半。如果它太小，那么我们只看元素更大的一半。通过这种方式，我们可以将每一步剩下的选项数量减少一半，直到找到为止。

最坏的情况是什么？当我们想要的元素根本不在列表中时。然后我们将进行比较，直到我们消除了列表的所有区域，并且没有更大或更小的一半剩下。

有关二分搜索的动画，请参阅[这些幻灯片。](https://docs.google.com/presentation/d/1P4HKmsO3Aaugv7_U16jJN0UbfTEJi1uZUdi_WbIIGe0/edit#slide=id.g463de7561_042)

二分搜索的直观运行时间是什么？花点时间使用您知道的工具来考虑这一点。

```apl
依旧是按照最坏运行情况来看，
思路一：
对于一个8个数字的有序数组，我们最坏的时候就是到最后一步还没找到，就是3次
对于一个16个数组的有序数组，就是4次，
也就是logN
```

我们从 n 个选项始，然后是 n/2，然后是 n/4 ...直到我们只有 1 个。每次，我们将数组切成两半，所以最后我们必须总共执行log_2(n)操作。

重要的是要注意，但是每个步骤并没有将它*完全*切成两半。**如果数组的长度是偶数，并且没有“中间”，我们必须取稍微较小或稍微较大的部分。**但这是一个很好的直观方法。

接下来我们将做一个精确的方法。

为了精确计算二分查找的运行时间，我们将计算操作的数量，就像我们之前所做的那样。

首先，我们定义我们的成本模型：让我们使用递归二进制搜索调用的数量。由于每个调用中的操作数量是恒定的，因此调用的数量将是唯一会根据输入的大小而变化的东西，因此这是一个很好的成本模型。

就像我们之前看到的那样，让我们为特定的 N 做一些示例计数。作为练习，在继续之前尝试填写此表：

| N         | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   |
| :-------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Count** | 1    | 2    | 2    | 2    | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 4    |

Alright, here's the result:

| N         | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   |
| :-------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Count** | 1    | 2    | 2    | 3    | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 4    |

这支持了我们推断出的时间复杂度为log2(*n*)的观点. 我们还可以发现，当N每到一个2次幂的时候，Count会加1

...但我们可以更精确： *C* ( *N* ) = ⌊ *l*og2( *N* ) ⌋ + 1 （这些 L 形条是“地板”函数，它是表达式向下舍入到最接近的整数的结果。）

几个值得了解的属性：

⌊*f*(*N*)⌋=Θ(*f*(*N*)) 

⌈*f*(*N*)⌉=Θ(*f*(*N*)) \log_p(N) = Θ(log*q*(*N*))

**以上的式子基本上说明对于对数运行时，对数的底根本不重要，因为它们在 Big-O 方面都是等价的（这可以通过应用底的对数变化来看出）**。应用这些简化，我们可以得到：

Θ(⌊log2(*N*)⌋)=Θ(log*N*)

正如我们的直觉所期望的那样。

### 总结一个很酷的事实

log非常好！它几乎与恒定时间一样快，并且比线性时间好得多。这就是为什么我们喜欢二分搜索，而不是一步一步地遍历我们的列表并寻找正确的东西。

To show this concretely:

| N                   | \log_2 Nlog2*N* | Typical runtime (nanoseconds) |
| :------------------ | :-------------- | :---------------------------- |
| 100                 | 6.6             | 1                             |
| 100,000             | 16.6            | 2.5                           |
| 100,000,000         | 26.5            | 4                             |
| 100,000,000,000     | 36.5            | 5.5                           |
| 100,000,000,000,000 | 46.5            | 7                             |

## 归并排序 — 聪明 — 选择排序很慢，合并有序很快

在我们的最后一个示例中，我们将分析归并排序，这是另一种很酷的排序算法。

首先，让我们提回想一下选择排序，其中的思想将被我们用于归并排序最初的构建块操作。

**选择排序**有两个基本步骤：

- 在未排序的项目中找到最小的项目，将其移动到前面，并将其“固定”到位。
- 使用选择排序对剩余的未排序/未固定项目进行排序。

如果我们分析选择排序，我们会发现它是Θ ( *N*^2).

**练习：**再次证明选择排序有Θ ( *N*^2 )运行时，通过几何方法工作（尝试在每次排序调用时绘制列表的状态）或计算操作。

| N = 6 |      |      |      |      |      |      |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
|       |      | √    | √    | √    | √    | √    |
|       |      |      | √    | √    | √    | √    |
|       |      |      |      | √    | √    | √    |
|       |      |      |      |      | √    | √    |
|       |      |      |      |      |      | √    |
|       |      |      |      |      |      |      |

让我们在这里介绍另一个想法：**任意时间单位**。虽然某件事所花费的确切时间取决于机器、特定操作等，但我们可以通过我们的任意单位 (AU) 获得一般的时间感。

如果我们运行 N=6 选择排序，并且运行时间是 N^2，运行大约需要 36 个 AU。如果 N=64，运行大约需要 `4096 / 2 = 2048` 个 AU。现在我们不知道那是 2048 纳秒、秒还是年，但我们可以对每个大小的 N 所需的时间有一个相对的了解。

### 记住这个想法，以备日后分析

现在我们有了选择排序，让我们来谈谈**归并排序。**

假设我们有两个**排序**数组，我们想将它们组合成一个大的排序数组。我们可以将一个附加到另一个，然后重新排序，但这并没有利用每个单独的数组已经排序的事实。我们如何利用它来发挥我们的优势？

事实证明，我们可以使用 sorted 属性更快地合并它们。**合并后的数组的最小元素必须位于两个列表之一的开头。所以让我们比较一下，把最小的元素放在我们新列表的开头。**

**现在，下一个最小元素必须位于两个列表之一的新开始处。我们可以继续比较前两个元素并将最小的元素移动到适当的位置，直到一个列表为空，然后将另一个列表的其余部分复制到新列表的末尾。**

要查看这个想法的动画，[请转到此处](https://docs.google.com/presentation/d/1mdCppuWQfKG5JUBHAMHPgbSv326JtCi5mvjH1-6XcMw/edit#slide=id.g463de7561_042)。

合并的运行时间是多少？我们可以使用对新列表的“写入”操作的数量作为我们的成本模型，并对操作进行计数。由于我们只需要编写每个列表的每个元素一次，因此运行时是 Θ ( *N* ).

**选择排序很慢，合并很快。我们如何将这些结合起来以加快排序速度？**

**我们之前注意到，在 N=64 列表上进行选择排序将花费 ~2048 AU。但是，如果我们对一半大的列表进行排序，N=32，它只需要 ~512 AU。速度是原来的两倍多！因此，使我们排序的数组更小可以节省大量时间。**

归并是线性运行时，只需要 ~64 AU。所以总的来说，把它分成两半，排序，然后合并，只需要 512 + 512 + 64 = 1088 AU。比选择排序整个数组更快。但是快多少呢？

现在，AU 不是真正的单位，但它们有时比查看运行时更容易、更直观。我们的 split-in-half-then-merge-them 排序的运行时间是N + 2(N/2)^2，大约是一半N^2用于选择排序。然而，他们仍然是Θ ( *N*^2 ).

**如果我们再次将数组减半怎么办？会好起来吗？是的！如果我们进行两层合并，从大小为 N/4 的列表开始，总时间约为 640 AU。**

**练习：**通过计算对每个子列表进行排序然后将它们合并到一个数组中的时间来说明为什么时间约为 640AU。

```apl
64 -> 16 16 16 16
16 -> 256 / 2 = 128
16 -> 256 / 2 = 128
16 -> 256 / 2 = 128
16 -> 256 / 2 = 128
16 + 16 = 32
16 + 16 = 32
32 + 32 = 64
∴
128 * 4 + 32 + 32 + 64 = 640
```

如果我们再减半呢？然后再次？然后再次？

最终我们将到达大小为 1 的列表。此时，我们甚至不必使用选择排序，因为具有一个元素的列表已经排序。

这就是**归并排序的本质：**

- 如果列表大小为 1，则返回。否则：
- 合并排序左半部分
- 合并右半部分
- 合并结果

那么**归并排序**的运行时间是多少？

我们知道合并本身是 N 阶，所以我们可以从查看合并的每一层开始：

- 要获得顶层：合并 ~64 个元素 = 64 AU
- 第二层：合并~32个元素，两次= 64 AU
- 第三层：~16*4 = 64 AU
- ...

AU 中的总体运行时间约为 64 * k，其中 k 是层数。这里，k = log_2(64) = 6，因此归并排序的总成本约为 384 AU。

现在，我们之前看到拆分更多层更快，但仍然是有序的N^2，那么合并排序比N^2快吗？

是的！

合并排序具有最坏情况运行时 = Θ ( *N* log *N* ) 

- 顶层需要〜N AU。
- 下一级需要 ~N/2 + ~N/2 = ~N。
- 再下一级：~N/4 + ~N/4 + ~N/4 + ~N/4 = ~N。

因此，总运行时间为 ~N * k，其中 k 是级别数。

有多少级？我们拆分数组直到它的长度为 1，所以k = log_2(N) 因此，整体运行时间是Θ ( *N* *l* *o* *g* *N* ).

------

**练习：**使用准确的计数来论证 Θ ( *N* *l* *o* *g* *N* ). 考虑到我们无法将列表完美地分成两半的情况。

------

**Θ ( *N* *l* *o* *g* *N* )比Θ ( *N^*2 )快? 是的！是质变！**

**但是线性时间  Θ (N) 并不比 Θ ( *N* *l* *o* *g* *N* )快多少。**

![Timing_table_for_runtimes](https://joshhug.gitbooks.io/hug61b/content/assets/timetable.png)

### 总结

- 分析代码运行时没有神奇的捷径。
- 在我们的课程中，可以进行精确计数或直观分析。
- 知道如何求和 1 + 2 + 3 + ... + N 和 1 + 2 + 4 + ... + N。
- 我们不会在这堂课上写数学证明。
- 您将在本课程中完成的许多运行时问题类似于今天的五个问题之一。有关更多练习，请参阅教科书、学习指南和讨论。
- 该主题具有课程中所有主题的最高技能上限之一。所有的工具都在这里，但**练习**是你的朋友！
- 对同一问题的不同解决方案，例如排序，可能有不同的运行时间（对于运行时间的差异足够大，以至于从不切实际变为实用！）。
- N^2 对比 N log(N)是一个巨大的差异。
- 从N log(N) 到 N 还不错，但不算很大的改进。

希望这组示例为运行时分析的技术和模式提供了一些良好的实践。请记住，没有神奇的捷径，但您必须使用工具来解决问题。快去分析！！



