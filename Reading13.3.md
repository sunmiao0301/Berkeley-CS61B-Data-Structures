## Reading 13.3

# The Implementation

堆的真正实现，与我们在上一章末尾讨论的表示非常相似。**不同之处在于我们将在数组的开头留一个空白点以简化计算。**

- `leftChild(k)`= *k* * 2
- `rightChild(k)`= *k* * 2 + 1
- `parent(k)`= *k* / 2

## 与替代实现的比较

| 方法             | 有序数组  | 浓密的 BST | 哈希表    | 堆        |
| ---------------- | --------- | ---------- | --------- | --------- |
| `add`            | Θ ( *N* ) | Θ (log N)  | θ ( 1 )   | Θ (log N) |
| `getSmallest`    | θ ( 1 )   | Θ (log N)  | Θ ( *N* ) | θ ( 1 )   |
| `removeSmallest` | Θ ( *N* ) | Θ (log N)  | Θ ( *N* ) | Θ (log N) |

惊人的！我们可以看到我们改进了运行时，也解决了重复元素的问题。笔记：

- 堆操作是**摊销**分析，因为数组必须调整大小（没什么大不了的）
- `getSmallest`如果将指针存储到最小元素，则BST 可以具有恒定时间
- 基于数组的堆占用的内存大约是使用方法 1a（指向子级的直接指针）表示堆所需的内存的 1/3

一些挥之不去的实施问题。

1. 优先队列 将如何知道如何对元素进行排序？假设我们有一个狗的优先队列，它会按重量还是品种排序？
2. 有没有办法允许灵活的排序？
3. 我们可以做些什么来将 MinPQ 变成 MaxPQ？

**练习 13.3.1。**回答上面的问题。



