## Reading 8.4

## Omega和摊销分析

在本节中，我们将结束对渐近的讨论。**大部分内容要到课程后期才会展开。**本节扩展了 Big O 的概念并介绍了 Omega。我们还将探讨摊销运行时的概念及其分析。最后，我们将以对运行时的实证分析和复杂性理论的预演结束。

### 运行时分析细节

**练习：**R( N )是 dup3 的运行时间（N是数组长度），那么R(N)的时间复杂度如何？

```java
public boolean dup3(int[] a) {
    int N = a.length;
    for (int i = 0; i < N; i += 1) {
        for (int j = 0; j < N; j += 1) {
            if (a[i] == a[j]) {
                return true;
            }
        }
    }
    return false;
}
```

**回答：** *R* ( *N* ) ∈ Θ ( 1 )，它是恒定的时间！那是因为 dup3 中有一个错误：它总是将第一个元素与自身进行比较。在第一次迭代中，i 和 j 都是 0，所以函数总是立即返回。无赖！

让我们修复 dup4 中的错误，然后再试一次。

**练习：**R( N )是 dup3 的运行时间（N是数组长度），那么R(N)的时间复杂度如何？

```java
public boolean dup4(int[] a) {
    int N = a.length;
    for (int i = 0; i < N; i += 1) {
        for (int j = i + 1; j < N; j += 1) {
            if (a[i] == a[j]) {
                return true;
            }
        }
    }
    return false;
}
```

**答：**这一次，运行时间不仅取决于输入的长度，还取决于数组的内容。在最好的情况下，R* ( *N* ) ∈ Θ ( 1 ). 如果输入数组包含所有相同的元素，那么无论它有多长，dup4 都会在第一次迭代时返回。

另一方面，在最坏的情况下，R* ( *N* ) ∈ Θ ( *N*2). 如果数组没有重复，则 dup4 永远不会提前返回，嵌套的 for 循环将导致二次运行时。

这个练习突出了 Big Theta 的一个限制。**Big Theta 将 的确切顺序表示为输入大小的函数**。但是，如果运行时不仅仅取决于输入的*大小*，那么我们必须在使用 Big Theta 之前将我们的语句限定为不同的情况。Big O 消除了这种烦恼。不必描述最好和最坏的情况，对于上面的例子，我们可以简单地说 dup4 的运行时间是O(N^2)，有时 dup4 更快，但最坏的情况是二次方。

### 大 O 虐待