## Reading 12.5

## 我们最终的数据结构：`HashTable`

我们之前几节一致在尝试创建的数据结构称为`HashTable`。

- 输入将被散列函数 ( `hashcode`) 转换为整数。然后，使用模运算符将它们转换为有效索引。然后，将它们添加到该索引处（使用 LinkedLists 处理冲突）。
- `contains`通过找出有效索引并在相应的 LinkedList 中查找该项目，以类似的方式工作。

## 处理运行时 Run Time

剩下要解决的唯一问题是运行时问题。如果我们有 100 个项目，并且我们的 ArrayList 的大小为 5，那么

- 在最好的情况下，所有项目都会均匀地发送到不同的索引。也就是说，我们有 5 个linkedList，每个包含 20 个项目。
- 在最坏的情况下，所有项目都被发送到同一个索引！也就是说，我们只有 1 个 LinkedList，它包含所有 100 个项目。

有两种方法可以尝试解决此问题：

- 动态增长我们的哈希表。
- 改进我们的哈希码

### 动态增长哈希表 —— 负载因子

假设我们有 M 个桶（索引）和 N 个项目。我们说我们的**负载因子**是 N / M。

（请注意，**负载因子**相当于我们上面的**最佳**情况运行时 = 100 / 5 = 20）

所以......我们应该保持低负载率（毕竟，这是我们可以实现最佳运行时的方案！）

请注意，如果我们保持 M（桶的数量）固定，并让 N 不断增加，负载率不断增加。

策略？每隔一段时间，就翻倍 M， 我们这样做的方式如下：

- 创建一个新的 HashTable，让其有 2M 个桶。
- 遍历旧 HashTable 中的所有项目，并将它们一个一个添加到这个新的 HashTable 中。
  - 我们需要一个一个地添加元素，因为由于数组的大小发生了变化，模数也发生了变化，因此该项目可能属于新哈希表中与旧哈希表中不同的桶。

我们通过设置**负载因子阈值**来做到这一点。一旦负载因子变得大于这个阈值，我们就会调整大小。

看看下面的例子。“helmet”的哈希码是 13。在第一个哈希表中，它被发送到存储桶13 % 4 = 1中，在第二个哈希表中，它被发送到存储13 % 8 = 5 中，**请注意，调整哈希表的大小也有助于 洗牌 哈希表中的项目**！

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%201.37.16%20PM.png)

此时，*假设项目是均匀分布*的，所有的列表将大约N/M长，导致Θ ( *N* / *M* ) 的运行时间。又因为我们之前假设 N/M 处在恒定**负载因子阈值**下（否则就resize了），因此，Θ ( *N* / *M* ) = Θ ( 1 )。

另请注意，调整大小需要 Θ ( *N* )时间。为什么？因为我们需要添加 N 项目到哈希表，每个添加都需要 θ ( 1 )时间。

A small point：在调整大小时，我们实际上不需要检查项目是否已经存在于 LinkedList 中**（因为我们知道没有重复项）**，所以我们只需通过θ ( 1 )的时间复杂度将每个项目添加到将其添加到链表的**最前面**。

（回想一下，通常我们必须搜索 LinkedList 以确保该项目不存在......但我们可以在调整大小时跳过该步骤。）

当然，我们需要重新审视我们假设项目是均匀分布的假设。如果项目没有均匀分布，我们的运行时将是Θ ( *N* )因为可能有一个大小 N 的链表

### 假设项目是均匀分布的？

如果我们有良好的散列码**（即为不同的项目提供相当随机的散列码）**，项目将均匀分布。通常这样做是......好吧......很难。

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%201.44.43%20PM.png)

一些普遍的良好经验法则：

- 使用类似于我们之前开发的“base”策略。（10进制 128进制）
- 使用一个小的质数的“base”。
  - **Base 126 实际上并不是很好，因为使用 base 126 意味着任何以相同的最后 32 个字符结尾的字符串都具有相同的哈希码。**
  - 这是因为溢出。
  - 使用素数有助于避免溢出问题（即由于溢出引起的冲突）。
  - 为什么是小素数？因为它更容易计算。

一些例子

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%201.49.51%20PM.png)

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%201.49.56%20PM.png)

# 下一步

哇，我们刚刚从头开始创建数据结构！为你们感到骄傲。应用您的知识完成 HW3：[https://sp19.datastructur.es/materials/hw/hw3/hw3\](https://sp19.datastructur.es/materials/hw/hw3/hw3/)

我们最终的数据结构：`HashTable`

