## Reading 11.3

# B树不变量

我们在第 11.1 章中提到，插入 BST 时顺序很重要。

**问题**：B-Tree 也是如此吗？

**练习 11.3.1**：按顺序将 1-7 插入到 B 树中。树的高度是多少？我们可以改变插入的顺序来降低高度吗？

**解决方案**：是的，我们可以通过按以下顺序插入高度为 1 的树：2、3、4、5、6、1、7。

是的，根据您插入节点的顺序，B 树的高度可能会发生变化。然而，这棵树永远是**浓密的。**

**B 树具有以下有用的不变量：**

- 所有叶子必须与源的距离相同。
- 一个有着k个元素的节点，其必须有k+1个孩子节点

同时，这些不变量导致树总是浓密的。

## B-Tree 运行时分析

在 B 树中搜索的最坏情况运行时情况是，如果每个节点中的元素数量最多，我们必须一直遍历到底部。我们将使用L表示每个节点中的元素数。这意味着需要探索 Log N ，并且在每个节点上我们都需要探索 L 个元素。总的来说，我们需要运行L log N 操作。然而，我们知道 L 是一个常数，所以我们的总运行时间是*O* ( log *N* ) 

## B-Tree 删除（额外）

如果您好奇，请参阅[这些额外的幻灯片。](https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305)我们不会在这里讨论它们。

### 概括

BST 具有最好情况下的高度Θ (log N)，和最坏情况高度Θ ( *N* ).

B-Trees 是对BST的一种修改，它避免了Θ ( *N* )最差的情况。

- 节点可能包含 1~L 个项目。
- 工作方式几乎与 BST 完全相同。
- **add 通过将项目添加到现有的叶节点来工作。**
  - 如果节点太满，它们就会分裂。
- 结果树具有完美的平衡。操作的运行时间是*O* ( log *N* )
- 没有讨论删除。如果您好奇，请查看额外的幻灯片。
- 还没有讨论如果L > 3，分裂是如何工作的（参见其他课程）。
- B 树更复杂，但它们可以有效地处理任何插入顺序。















